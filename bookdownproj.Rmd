--- 
title: "WFC 70: Data Literacy for Wildlife Biologists"
author: "Rob Furrow"
date: "`r Sys.Date()`"
site: bookdown::bookdown_site
---

# Welcome to WFC 70 {-}

The purpose of WFC 70 is to build your data literacy skills, with a focus on using R programming to wrangle, plot, and interpret data. 

This website is a mini-textbook where you can browse the course labs and explore other mini-lessons. Some lessons focus on troubleshooting common mistakes, other on shortcuts for maximum efficiency, and others on more advanced techniques to enable you to take on more complex data sets for your project.

This website was created by WFC 70 Learning Assistants! We hope it is of use :)

---

All videos in this website are created by Anthony Roberson. Sections are written by Rosaleen Hernandez, Zoe Smith, Seth Marshall, and Mingyuan Li, with some contributions from course instructor Rob Furrow.

<!--chapter:end:index.Rmd-->

# Getting Started {-}

Before we begin, it is recommended that you make a folder in your Google Drive and/or desktop on your personal computer, to keep your files. You may find Google Drive to be more effective due to it being able to be connected to multiple devices. 

## Installing R and R Studio

A program you will hopefully become familiar with is R and R Studio. Lecture and lab discusses the differences between these two.

R is the language you are using to create the graphs. R Studio is where you input the code. One way to think about it is that R Studio is the kitchen and R represents all your ingredients.

We will need both on your computer before your first lab. Even if you are not going to be bringing your personal computer to lab, having it can be helpful for homework and the Data Story.

<video width="420" height="340" controls loop="">
  <source src="https://github.com/rahhernandez/wfc70/raw/refs/heads/main/Draft%202.mov">
</video>

Once you have successfully downloaded both, don't be afraid to open R Studio and play around!

## Getting Started With Labs

A main component of WFC70 are the labs. The labs will be where you get to really practice the skills of data literacy. Before your first lab, below is a video to help you started with how things may go on first lab! 

## Working From Home

As expected, most homework assignments will be completed at home. At times, you will need to refer back to lab material to help accomplish the homework assignments, including the Data Story. Navigating things at home may be difficult, especially if you are utilizing your personal computer. Below is a video to help guide you through navigating R Studio from home! 


<!--chapter:end:02-gettingstarted.Rmd-->

# Intro to R and R Studio

## Packages

While base R Studio is great, sometimes we need to perform actions R Studio can not do without some outside help. This is where packages come in. Packages allow us to do more than base R Studio can. In WFC 70, the package we use the most is **tidyverse**. Tidyverse contains lots of packages for data visualization, including **ggplot2,** which allows us to make graphs. You will get familiar with tidyverse and it's possibilities!

### Installing Packages

The main way to install packages is through code.

```{r, warning=FALSE, message=FALSE, eval=FALSE}
install.packages("package name")
```

To make sure R Studio is aware of the package, you need to run the library function.

```{r, warning=FALSE, message=FALSE, eval=FALSE}
library("package name")
```


#### Downloading Tidyverse
For example to download *Tidyverse*, the main package utilized in WFC70, you will write:

```{r, warning=FALSE}
install.packages("tidyverse")

library(tidyverse)
```

Below is a video to guide you through downloading packages!

### Finding Packages

**Tidyverse** and **ggplot2** may be the most used package in this class, but there are plenty of packages out there!

The simple way of finding packages through Google, Github or even R community posts. There are many people who have compiled lists of useful R packages.

Here some useful lists of essential R packages!

-   <https://support.posit.co/hc/en-us/articles/201057987-Quick-list-of-useful-R-packages>

-   <https://data-flair.training/blogs/list-of-r-packages/>

-   <https://medium.com/data-science/a-comprehensive-list-of-handy-r-packages-e85dad294b3d>


## Knitting

The way RMarkdown (Rmd) files are saved is through a process called knitting. Knitting saves the files into an HTML, PDF or Word. In WFC 70, we mainly save our Rmd files into HTML files. Knitting, in the beginning, can be a bit difficult.

Below is a video to help guide you through the knitting process! Lab will also discuss how to knit. 




<!--chapter:end:03-introtor.Rmd-->

# Code not Working?

People make mistakes. It is a common process in coding that everyone, no just beginners experience. Here we will provide some tips if you make a mistake and provide tutorials for some potential complicated concepts.

## Checklist

There are some common mistakes people often overlook which cause the code not to work. If your code is not working, here are some things to double check:

1.  Check Spelling
    -   Does all your spelling match? Is the data you are referencing spelled ***exactly*** the same? For example, "cats" is not the same as "Cats".
    
2.  Reread Code
    -   A common mistake is missing an aspect of the code, such as a parenthesis, comma or plus sign. Reread and check to make sure you have all aspects of of your code.
    
3.  Compare to Previous Code
    -   A big aspect of coding is copying and pasting and altering to get what you need. If you altered previous code which previously worked, compare it to ensure it is the same.
    
4.  Seeking for Help
    - ***DO NOT RELY ON AI!*** AI will typically complicate your code and make you do more work. It is safer, and more reliable, to ask the instructor or TA!
    
If you have gone through the previous steps and the code is *still* not working, ask the instructor or TA! You can also Google your issue, as it is likely that other people have experienced the same issue and are looking for solutions.

### Example: Fix the Code

As a practice, see if you can identify what is wrong in this code and fix it! We will be using the Palmer penguins package.

```{r, warning=FALSE, message=FALSE, echo=FALSE,eval = FALSE}
install.packages("palmerpenguins")
library(palmerpenguins)
```
 
```{r, eval = FALSE}
penguins_raw 
```

```{r, eval=FALSE}
penguins_torgersen <- filter(Penguins_raw, island == "Torgersen")
```


# Importing Data

You will be working with a lot of data in this class (as expected). While lab may describe and guide how to download and import data, things get a bit more difficult when you look for data for your data project.


## Finding Data

As discussed in lecture, there are many places online to find data. The ones recommended in lecture include:

- Dryad
- Environmental Data Initiative
- University of Minnesota
- National Ecological Observatory Network
- Knowledge Network for Biocomplexity
- Breeding Bird Survey

Once you find your data, how do you determine if it is good or not? 

Do not be shy about working with messy data. Working with messy data is good and helps increase your data literacy skills. However, there is a difference between messy good data and messy bad data.  

Below is a small checklist to go through to make sure you are not biting off more than you can chew.

1. 
2.
3.





<!--chapter:end:04-tutorials.Rmd-->

# Data Wrangling

Data wrangling is an important factor in WFC 70. It will be a major aspect in aiding in your Data Story, and in any future class in which you will need to utilize data. However, it can be a bit confusing as to how to tie everything together. This module is meant to aid you through knowing how to apply certain data wrangling features.

## Review

First, we will go over a quick overview of the tools in Tidyverse which allow you to data wrangle. The main ones utilized in this class are:

-   filter
-   joins
-   select
-   mutate
-   pivot

### Filter

Filter, as the name suggests, selects only the *rows* which meets the conditions you want. This is helpful if you want to select only a particular species in a big data set.

### Joins

Joins combines two data sets into a singular data set through a common factor. For example, in Lab 6, we utilized left_join, and it is it the most commonly used join command.

-   left_join → keeps all observations in x
-   right_join → keeps all observations in y
-   full_join → keeps all observations in x and y

This is an article which goes deeper into joins if you are interested in playing around! The best way to learn is to also play around with your code and inputting the different joins to see what changes.

- <https://dplyr.tidyverse.org/reference/mutate-joins.html>

### Select

As the name suggests, select will only the *columns* of the data set you want to focus on. This is helpful in a large data set to only select certain columns such as weight, sex, length, etc.

Now that we have done a quick review of some of the essential codes needed for Data Wrangling, we now question how to tie them together for the Data Story.

### Mutate

Mutating allows you to form new columns. This can be done with any functions as long as it is the same length of all the other column. A single value will make that value be the same for the entire column length.

### Pivot

Pivot allows you to change the data from wide data (horizontal typically) to long data (vertical typically) and vice versa. This is helpful when you have data in which perhaps the columns are multiple weeks (Week 1, Week 2, etc.) with two taxa. It is difficult to plot data of multiple weeks–*unless you want to compare certain weeks*–so by combining all the columns of Weeks into "Weeks" so that the Week 1, Week 2, etc., become values rather than columns.

-   pivot_longer
-   pivot_wider

## Tying Everything Together

All these factors are simple on their own, especially in lab with simple, clean examples and what you want is known. These factors get a bit more complicated when you have to find and select the factors you want yourself. Data Wrangling may be the thing you find the most difficult when working with your own data.

### Checklist

It is important to go through a checklist to plan out your data wrangling plan. This checklist is for when you *find* your data.

***Note: It is easier to find data and then pose a question than to pose a question and then find data.***

1. **What factors do you want to compare?** Do not be scared about how big or messy looking your data may look like. Read the READ ME file and see what the data is about.

2. **Select the factors** This project is only as complicated as you make it. You do not need to compare a bunch of factors. If you found a data set of a survey of a ton of birds, which specific species do you want to focus on?

3. **How do you get the factors?** After you decide which rows and columns, which one of the data wrangling tools will you use? Think generally. The most common ones you would use would be select and filter. Utilize the other tools if they are necessary.

4. **Get those factors** Once you have considered the big picture, it is time to think of the more specifics. You should look back at previous labs and lectures for examples of codes you can utilize. Remember, a lot of coding is copying and paste.

### Example

Let us look at the penguin data once more.

```{r, warning=FALSE}
#installing the packages and running it

install.packages("palmerpenguins")
library(palmerpenguins)
```

Let us look at the raw data set.

```{r}
penguins_raw
```

Let me say that I want to make a data set of Gentoo penguins and am only concern with the columns of sex and flipper length. Which code would I use?

```{r, eval=FALSE}
gentoo <- filter(penguins_raw, species=="gentoo penguin (Pygoscelis papua)") |>
  select(Sex, flipper_length (mm))
```

```{r, eval=FALSE}
gentoo <- filter(penguins_raw, species="Gentoo penguin (Pygoscelis papua)") |>
  select(penguins_raw Sex, Flipper Length (mm))
``` 

```{r, eval=FALSE}
gentoo <- filter(penguins_raw, species=="Gentoo penguin (Pygoscelis papua)") |>
  select(Sex, Flipper Length (mm))
```

<!--chapter:end:05-datawrangling.Rmd-->

# Data Visualization  

A major part of Data Literacy is visualization. The main form which this is done is through the making of graphs. There are many graphs that are possible based on the comparison you wish to make. 

The main point of this section is to help guide you for which plots you can make.

## Types of Graphs

Here is a small little review of some of the graphs talked about in WFC 70 and when they may be useful.

### Histogram

A histogram is useful when comparing one categorical factor with values. For histograms, you can play with bin width and alpha (transparency).

![](https://github.com/rahhernandez/wfc70/raw/refs/heads/main/histogram.png)

### Violin Plot

A violin plot is a great way to visualize distribution of a sample, especially with seeing the variation present. It is a great way to visualize data if you feel as though a box plot does not truly convey the variation in your numeric values.

![](https://github.com/rahhernandez/wfc70/raw/refs/heads/main/violin.png)

### Box Plot

A box plot is a more uniformed way to visualize and display your data. This is most effective when there is a grand difference between the comparisons. If the box plots are too similar, then it can be more effective to utilize a violin plot.

![](https://github.com/rahhernandez/wfc70/raw/refs/heads/main/boxplot.png)

### Scatter Plot

A scatter plot plots each value as an individual point. It is useful when you have two numerical values as your x-value and y-value. It is also possible to plot multiple categorical values and have them represented through color. 

![](https://github.com/rahhernandez/wfc70/raw/refs/heads/main/scatterplot.png)

## Extra Resources 

Here are some extra resources for different graphs you can make and some introductory materials!

https://ggplot2.tidyverse.org/articles/ggplot2.html ← Introductory to ggplot2

https://r-graph-gallery.com/ ← Collection of R studio examples! A good resource because the graphs are sorted by what type of graphs that are

https://r-graph-gallery.com/ggplot2-package.html ← ggplot! Shows the different possibilities with ggplot, including annotation, labels, and titles

http://r-statistics.co/Top50-Ggplot2-Visualizations-MasterList-R-Code.html ← 50 Different ggplots! Fun to see the extent of ggplot

---

All images from past WFC 70 Lectures from Instructor Rob Furrow

<!--chapter:end:06-datavisualization.Rmd-->

# (APPENDIX) WFC Lab 1 (2025) {-}

# Lab 1: R, data, and the RStudio panels

In this lab, we will learn a few foundations of programming and get acquainted with R and RStudio.

By the end of this lab, you should be able to program in R to:

-   make arithmetic calculations,
-   create an object to hold a vector of values,
-   convert from a set of vectors to a data frame.

------------------------------------------------------------------------

## Part 1: Orienting ourselves to RStudio (10 minutes, instructor will lead)

On your lab computer, open up RStudio. With RStudio open, click File -\> New File -\> R Script. Your workspace should look something like this.

![The RStudio Workspace](../images/workspace.PNG)

Let’s begin by running some calculations in the console. R is basically a very fancy calculator. Run the next few lines by copying and pasting each one into the console, pressing the “Enter” key after each line.

```{r}
35+10

(6*2+48)/3

a <- 3

b = 3

a^2

#A^3 
```

What happened when you ran that final line of code when you uncomment it? Hint, take a look at the “Environment” pane in the upper right of RStudio. What are the names of the objects that you stored? Which lines of code created those objects in the Environment? Is `A` in the Environment?

> ***Takeaway: You can store values (or sets of values) in R by assigning them a name. But NAMES ARE CASE SENSITIVE, so `A` is not the same as `a`.*** This named information is called an ***object***, and it could be anything from a single value, a spreadsheet with many columns of measurements for many individual organisms, a list containing a wide array of information, or even a function that can be used to make complex calculations.

### The command line / "Console" versus a R script

Our workspace may still feel a little confusing. We have asked you to write things in an R script (upper left) and then copy them into the console(also called the *command line*, lower left) and press enter. R will only actually run the code that is entered into the console. But if you only program in the console, you won't have useful documentation of everything you've done, and it may be hard to reproduce. ***And, if you close R, everything you've entered will be gone.***

Instead, R programmers will generally write scripts (which are files that end in the suffix ".R"), so they can have a single place to save all the code they used for a particular task or project. Later in the course we'll learn an even more flexible way to document our code using an RMarkdown file, which allows you to integrate regular text, R code, and R plots and other outputs into one easy-to-read document. But that's too much for today. Let's delve a little deeper into R's features.

### R data is often stored in "vectors"

A vector in R is a way to store a sequence of values. In our case, the vectors we look at will usually be a sequence of numbers, but they could also be storing a set of TRUE/FALSE values, a set of “strings” (i.e. letters/words/sentences) or a few other types. Much of the data you use in R will be stored as vectors, often organized with each vector as a column in a bigger matrix/spreadsheet of data (this is called a data frame). Let’s create some vectors. We will use a function in R called `c()`. That function lets you combine a sequence of values into a vector. You enter each value, separated by a comma.

From this point onward, you should initially write/paste the code into your script (upper left), then run those lines in the console. You can directly run the lines in a script by pressing the `Crtl`+`Enter` keys at the same time (it's `Cmd`+`Enter` on a Mac), while your cursor is on that line of code. Try that for this next set of commands.

```{r, eval = T}
idaho_wolves <- c(1545, 1556, 1543, 1337)
idaho_years <- c(2019, 2020, 2021, 2022)
```

Look at your upper right panel in RStudio. You should see two new objects in your environment. When your line of code is storing a new object in the environment, it won’t show any output. But you can always enter the name of that object into the console and press enter to view it. (*Tip: If you start writing a name, R will try to autocomplete, you can press `Tab` to take its suggestion.*)

```{r, eval = T}
idaho_wolves
```

Now let’s have R do something useful. `c()` was the first function you’ve seen, but R has lots of functions. When you run a function, it will always have round brackets, `()`, usually with some inputs inside. In programming, we call the inputs to a function the ***arguments***. Let’s try out another function, `mean()`. This function’s main argument is a vector, and it will calculate the average of the values in the vector.

```{r}
mean(idaho_wolves)
```

Two related functions are `length()`, which tells you how many values are in your vector, and `sum()`, which adds up all the values. The mean of a vector is just the sum divided by the length, so you can try to calculate the same value we calculated above using `sum()` and `length()`.

```{r}
sum(idaho_wolves)/length(idaho_wolves)
```

------------------------------------------------------------------------

------------------------------------------------------------------------

## Part 2: Trying things out yourselves (10 minutes, on your own)

1.  Create two data vector using these data. The first should be called `mt_wolves`, and the second `mt_years`.

```{r}
# write code to store these data as mt_wolves
c(1119, 1107, 1147, 1153, 1181, 1143, 1087)

# write code to store these data as mt_years
c(2016, 2017, 2018, 2019, 2020, 2021, 2022)
```

2.  Calculate the mean of `mt_wolves` using the `mean()` function.

3.  Run the code `plot(x = mt_years, y = mt_wolves)`. You should see a plot labeled with "mt_years" on the x-axis and "mt_wolves" on the y-axis.

Check in with your neighbor – does this population appear to be stable? What else would you want to know? Are you happy with the way this plot is representing these data?

4.  (Time permitting). *If you have finished quickly, this question provides some extra prompts for you to explore. This material will not be assessed on HW 1.* So far you ran the `plot()` function using only two arguments (the x-values and the y-values). `plot()` can take many more arguments as well, including specifying better limits for your x- and y-axes. Run the code `plot(x = mt_years, y = mt_wolves, ylim = c(0,1200))`. What is different about this plot from your previous one? Try out some different numbers there, or add an additional argument `xlim` to adjust the x-axis.

------------------------------------------------------------------------

------------------------------------------------------------------------

## Part 3: Making toast (10 minutes total)

Open google drive and create a folder for WFC 98. Then make a google doc to use for notes for the non-coding parts of today. Take 2 minutes to think about and write down the steps required to making toast, starting with a bag of bread and a toaster. Imagine you are explaining this to a 5-year-old who is a reasonable human being, but has never used a toaster by themselves.

After 3 minutes, check in with your neighbors to your left and right. If you are by yourself, feel free to scoot over to a different station to chat with folks.

### Class discussion (5 minutes, instructor will lead)

------------------------------------------------------------------------

------------------------------------------------------------------------

## Part 4: Data frames to link data together (5 minutes, instructor will lead)

Hopefully the toast-making activity has you thinking about giving precise directions. It can be very helpful to try to imagine any line of R code into a sentence, and practice saying exactly what you think that code is doing. In an R script, we can actually do that using ***comments***. A comment is a line of code/text that will NOT be run, but can provide useful notes to remind you what particular code chunks are doing. Comment lines start with the hashtag symbol, `#`. Pay attention to the comments in the code below.

Most data you work with in R will not be stored as many individual vectors. Instead, there is a useful data structure called a ***data frame*** that can keep track of several associated values. It might be easier to think about this with an example. Run the following code to make a data frame with both wolf population and years for the state of Idaho.

```{r}
# This code creates a data frame with a column named "population" that has values from
# the idaho_wolves vector, and a column named "year" with values from 
# idaho_years
idaho <- data.frame(population = idaho_wolves, year = idaho_years)
```

Let's check out this new object, `idaho`, in our environment (top right). It says "4 obs. of 2 variables". Now click on its name ("idaho") in the environment. R should open a new tab in the upper left that shows you a spreadsheet version of those data. There are four rows and two columns. They correspond to four observations (the population in each of those four years), and we have two variables associated with each observation (the number of wolves and the year).

More generally, data frames in R offer a way to store spreadsheet data as a single object, with rows corresponding to the number of observations in your data set, and columns representing the variables. The columns can have pleasantly descriptive names to help you know what they represent; here they are "population" and "year". Part of your first homework will guide you through a few more steps for manipulating data frames.

------------------------------------------------------------------------

------------------------------------------------------------------------

## Wrapping up (5 minutes)

Finally, you should have a lot of code written out in your script. Make sure that you save that script (In the very upper left of RStudio click on "File" then "Save As..." and save it to the computer's desktop.) Then save the .R file it to your WFC 98 google drive folder. Be sure also that it has a nice, descriptive file name, like "WFC98_lab1.R", so that you can easily find it later. Make sure that your google doc with notes from today is also saved in the WFC 98 folder.

------------------------------------------------------------------------

------------------------------------------------------------------------

## Extra material for interest (will not be assessed on any homework)

-   Under the Tools tab (top of your workspace), you can open "Global Options...". Explore through here to see ways to customize your RStudio workspace. You may want to try out some other "Editor themes" in the "Appearance" tab.
-   There is a great graduate student course called R-DAVIS that has lots of useful materials online. Check out their introductory lesson here: <https://gge-ucd.github.io/R-DAVIS/lesson_01_intro_r_rstudio.html>.

<!--chapter:end:07-lab1_2025.Rmd-->

# Lab 2: Indicies in R, R Markdown

In this lab, we will do a small amount of R programming, learn how to write 
reproducible analyses using R Markdown, and get started on skills to read 
primary literature. 

By the end of this lab, you should be able to:

* use indices and data frame column names to select particular pieces of 
data,
* edit an R Markdown file to integrate text and code and change the document 
style,
* knit an R Markdown file.


## Part 0: Figure of the week (5-10 minutes, instructor leading)

***
***

## Part 1: R vs. RStudio, .R vs. .Rmd files (5 minutes, instructor leading)

### R vs. RStudio

This short section has some clarifications about the programs we are use.
You are using the programming language R. That is the primary skill you are 
developing in these labs. But the program we open to write our R code is called 
RStudio. RStudio is known as an IDE (an *integrated development environment*), 
which is a fancy way to say that it is a useful program in which to write and 
run your R code. So, on a future CV, say that you are proficient in R (and, 
soon enough, R Markdown). You don't have to explicitly mention RStudio.

This raises another issue that throws people off at the start. ***Always begin
your programming sessions by opening RStudio, not just the R program.*** The 
default R program is not a very user friendly environment for coding and does 
not work well with R Markdown (.Rmd) files.

### R scripts (.R files) vs. R Markdown files (.Rmd)

When people are performing substantial amounts of R programming, they tend to 
write their code in scripts.  These are files that end in ".R", and they are 
intended to include nothing but code (ideally with some comments as well).

However, R scripts do not provide an easy way to combine regular text and code. 
Sure, you can (and should) add comments to your code to explain what each line 
is doing. But comments are not an easily readable way to include large amounts 
of text. R scripts also do not allow for images, plots, or displays of the 
results of code.

That's where R Markdown comes in.  With a ".Rmd" file, the default
is that you are writing text. However, you can also add code chunks with R code,
and have that code run to generate interesting plots or other outputs.

## Part 2: Indices and column names (5 minutes, instructor will lead)

Let's pull up last week's data very quickly.

```{r}
idaho_wolves <- c(1545, 1556, 1543, 1337)
idaho_years <- c(2019, 2020, 2021, 2022)

idaho <- data.frame(population = idaho_wolves, year = idaho_years)
```

It is often the case that you want to select only a particular column in a 
data frame, or a particular value in a vector. Let's see first, then discuss.


```{r}
idaho_wolves[4]

idaho$year
```

You should note that `idaho_wolves[4]` outputs the 4th value in that vector
(1337).  And that `idaho$year` shows you the entire `year` column in the
data frame `idaho`. 

Let's look at some more complex code.

```{r}
idaho_wolves[1:3]
idaho_wolves[c(1,3)]

idaho$year[2]
idaho[1,2]
```

A few things to unpack. First, we used a very odd function (the `:` operator), 
which is a quick way for R to create a vector that is a sequence of numbers.  
The code tells us to pull the 1st through 3rd entry in our vector. This function 
will often be useful. Try running `7:20`, then try running `10:5`. That's right,
it even works backwards.

Next, if we want to specify several entries, we can't just write 1,3. We need to
make the relevant indices (1 and 3) into a vector as `c(1,3)`. Then we use that
inside our square brackets to find the 1st and 3rd entry.  

Because `idaho$year` is just a vector (from that column's values), we can pick
particular entries in the same way. However, if we have a dataframe, there are
both rows and columns. In that case, you would entry two values/vectors: one 
for the row(s) and one for the column(s). So `idaho[1,2]` gives you the value
from the 1st row and second column.  We won't use this approach much -- there
are more sophisticated tools for selecting parts of our data for tidying or
plotting. 

## Part 3: Index work on your own (10 minutes, on your own)

Here are some new data.

```{r}
#creating a data frame for montana populations through time
mt_wolves <- c(1119, 1107, 1147, 1153, 1181, 1143, 1087)
mt_years <- c(2016, 2017, 2018, 2019, 2020, 2021, 2022)
montana <- data.frame(population = mt_wolves,
                      year = mt_years,
                      state = c("montana"))

```

We did something cute, and added a third column that just says "montana" in
literally every row. (Nice to keep the state associated with the data
in the other columns.)

Your tasks:

1. Write code to select the 3rd through 5th values in the `mt_wolves` vector.

2. Write code to select the 1st, 2nd, and 6th entry in `mt_years`.

3. Select just the `year` column in the `montana` data frame.

4. Create a new `idaho` data frame that includes a population column, a year
column, and a state column that just says "idaho" in every entry.

```{r}
# all code goes in here



```

## Part 4: Messing around with R Markdown (15 minutes, on your own)

In RStudio, if you click on the Help tab at the top, you will see a selection
labeled "Cheat Sheets".  Select "R Markdown Cheat Sheet", which will download
and open a pdf. This cheat sheet is also posted on Canvas in Files.
I find it a little overwhelming, but here you really
just need to focus on the right side of the first page "Write with Markdown".


This section has instructions about how to format text, create headers, make lists,
etc. Let's try things out.

1. **Knit this document to an html file.** To do this, click on the down 
arrow/triangle just to the right of the "Knit" button that is on the navigation 
bar below the name of the file. A dropdown menu will appear -- click "Knit to 
HTML".  

This should quickly create an html file (like the kinds that represent web 
pages) that you can view. It should include the text, code, plots, and 
formatted LaTeX formulas for population growth. Take a minute to see how 
different parts of the Rmd produced different kind of formatting.

Just above your Rmd file, you should also see a little button that says 
"Visual". If you select that, you can switch to a visual edit which allows for 
easy styling of an Rmd.

2. **Create some headers using the # symbol.** Which one is the biggest? The 
smallest?  You can create headers of six different sizes, from # to ######.

  # Put something here.

### Put something else here.

##### And some more.

3. **Style your text.**

Italicize this sentence.

Bold this sentence.

4. **Create an unordered list** (like bullet points in a powerpoint) of your 
five favorite foods. For one of the foods, add at least two sub-items (perhaps 
those could be specific variations of that food)

5. At the end of the previous section, we manipulated some Montana wolf
data. **Use these numbers to create a table with two columns** (first header
"year", second header "pop. size").



## Wrapping up (5 minutes)

Knit your file to HTML, and save the original Rmd, then add them to your WFC 98 
folder on Google Drive.

***
***

## Extra material for interest

* Browse [this article on R Markdown](https://rmarkdown.rstudio.com/articles_intro.html). 
Try creating a new .Rmd file and exploring.

* Try adding the option "echo=FALSE" to the top of an R code chunk (see 
the examples in the bottom left on the first page of the R Markdown cheat 
sheet). How does the HTML file look different after you knit the .Rmd file 
again? What about using
"eval=FALSE"?

<!--chapter:end:08-lab2_2024.Rmd-->


# Lab 3: Visualizing data in R (Part 1)


In this lab, we will get into one of the really fun parts of R programming --
***making figures!***

By the end of this lab, you should be able to:

-   load an R package using the `library()` function,
-   install R packages as needed using `install.packages()`,
-   use the `ggplot2` package within the `tidyverse` to write simple code to 
    plot data,
-   create boxplots, histograms, and scatterplots to compare the distributions
    of different subgroups of data.

### Resources

This lab is loosely based on chapter 1 in the online textbook "R for Data
Science" (second edition), which you can find online here:
<https://r4ds.hadley.nz/data-visualize>

## Part 0: Figure of the week (5-10 minutes, instructor leading)

--------------------------------------------------------------------------------

--------------------------------------------------------------------------------

## Part 1: Packages in R (covered in lecture, so only here for reference)

Many functions and data in R are not instantly available. Instead, they are
available online as "packages". Packages extend the usefulness of R with new
functions and data (and documentation/metadata), and they are hosted online in a
standard way for easy installation and loading.

### Installing an R package

*Installing an R package* is easy to do within RStudio. In the computer labs we
have already installed most R packages that you will need for any coding in WFC
98. However, when you are programming on your personal computer you will need to
install any packages that need to be loaded for a particular lab or HW. ***You
only need to install an R package once.***

The code chunk below is only necessary if you are working on this lab at home,
because these packages are already installed in the computer lab.

```{r}
# the line below is commented so it won't run.
# if you need to install the packages, delete the hashtag then run 
# the line below, but then turn it into a comment again
# before knitting

# install.packages(c("tidyverse", "palmerpenguins"))


```

***Delete or comment out any install.packages() commands before you knit.
You cannot knit an Rmd that still has active install.packages() code.***

### Loading an R package

***On the other hand, you must have code to load any relevant R packages
inside of your Rmd if you go on to use functions/data from those packages
in your Rmd.***

*Loading an R package* tells R/RStudio that you plan to use that package during
your current sessions. ***You need to load an R package in every session that
you use it.*** After it is loaded, it will stay loaded until you close
R/RStudio.

```{r}
# loading the tidyverse package
library(tidyverse)
```

If you run this code and get the error message that there is no package called
'tidyverse', that means that the package is not installed, and you'll need to
use the earlier code to install it.

Assuming everything worked, in your output you'll notice a somewhat odd message.
It says "Attaching core tidyverse packages" and then lists several cryptic
names. Unlike most packages, `tidyverse` is a suite of multiple R packages, but
you can load them all in one line to save time, because they are commonly used
together.

Today we are primarily using functions from the `ggplot2` package, which was
loaded when we used the `library(tidyverse)` command in the code chunk above.

### Part 1b (5 minutes, instructor leading)

We also need to load the package with the penguin data.

```{r}
#loading the palmerpenguins package, which contains two data frames
library(palmerpenguins)
```

There is one odd thing about data sets that are included in R packages. You will
notice that nothing new has shown up in the global environment. However, the
data frames are actually loaded (but hidden).

```{r}
penguins
penguins_raw
```

I prefer to formally load the data into my environment, which you can do with
the `data()` function.

```{r}
# the palmerpenguins package called their data "penguins"
# and the command will load both data frames
data(penguins)
```

Now we can see the data frames in our environment. Let's take a closer look.

```{r}
# the glimpse() function lets you see the variable (columns) and
# a few observations for each variable (rows)
glimpse(penguins)
glimpse(penguins_raw)
```

A few questions to orient ourselves to these data.

1.  Which data frame has more variables, or are they the same?

2.  Which data frame has more observations, or are they the same?

3.  What is different about the column/variable names in `penguins` as compared
    to `penguins_raw`?


## Part 2: Using ggplot() for plotting in R (15 minutes, self-led)

The core function in the `ggplot2` package is called `ggplot()`. But making
plots using `ggplot()` is like making lasagna. You have to add layers until
you've produced the perfect result.

Recall from lecture that we need the base canvas with the data (and aesthetics),
as well as at least one additional *geometry* layer. We will see lots of types 
of `geom` in this course. We'll briefly begin with a critical type of plot, 
the scatterplot. That shows two-dimensional points to illustrate the 
relationship between the x- and y-axis. It has a geometry called `geom_point()`.

```{r}
ggplot(data = penguins,
  mapping = aes(x = flipper_length_mm, y = body_mass_g)) +
  geom_point()
```

Hooray, we have made our first ggplot! However, today we want to practice
making histograms and boxplots. So we'll need some slightly different aesthetics
and geometries. We only started with scatterplots because they are so common,
and they have a very clearly defined x- and y-axis.

***Before we move on, there is one crucial thing to note: each time you add a
new layer (e.g. a `geom`, some labels for nicer x- and y-axis titles, etc.) you
need to have a plus symbol, +, at the end of the previous line of code.
Otherwise R does not know to keep looking for additional layers before making
the plot.***

Let's try out a histogram. First, we might simply want to visualize the
distribution of all of our measurements of bill length.

```{r}
ggplot(data = penguins,
  mapping = aes(x = bill_length_mm)) +
  geom_histogram()
```

Because histograms just count values for one variable, there is only
one aesthetic (`x=bill_length_mm`). The geometry was for a histogram is
`geom_histogram()`. There are a few things we might want to consider.

-   This has a lot of separate bins. We might say it is a very *fine-grained*
    histogram. We can adjust that with *arguments* inside of `geom_histogram()`.
-   This is summarizing data from multiple species at once. That is not very
    meaningful. We can separate these out in several different ways.

To address the first issue, you may have noticed that geometries are also
functions, so their output can be modified using arguments just like most other
functions in R. By default this function creates 30 bins (thirty separate
x-values/bars) for a histogram. Let's specify a smaller number.

```{r}
ggplot(data = penguins,
  mapping = aes(x = bill_length_mm)) +
  geom_histogram(bins = 20)
```

Alternatively, we could specify a `binwidth`, setting how wide each bin should
be. Let's try using a `binwidth` of 2 (the units for this column are millimeters.)

```{r}
ggplot(data = penguins,
  mapping = aes(x = bill_length_mm)) +
  geom_histogram(binwidth = 2)
```

Now for the fun part. We can quickly add informative complexity. Let's keep 
track of all three species in our histogram. We can add the `fill` aesthetic 
`fill` and the very similar `color` aesthetics allow you to color code different
data points based on another variable/column in your data. Let's try `color` 
first and see why it is NOT ideal here.

```{r}
ggplot(data = penguins,
  mapping = aes(x = bill_length_mm, color = species)) +
  geom_histogram(binwidth = 2)
```

Hmmm, this is not right. We want the whole bars colored. For some geometries,
`color` only changes the borders, not the full shapes. But color will often be
useful, for example to change the color of points when using `geom_point()`. To
fill in a whole shape with color, you use `fill` instead.

```{r}
ggplot(data = penguins,
  mapping = aes(x = bill_length_mm, fill = species)) +
  geom_histogram(binwidth = 2)
```

This is still not quite right. It is showing all the data, now color-coded, but
it is stacking the numbers rather than showing three separate histograms with
some overlap in the x-values. That is because `geom_histogram()` defaults to
stacking data, even if there is a `fill` aesthetic. You can fix that by changing
another argument called `position`.

```{r}
ggplot(data = penguins,
  mapping = aes(x = bill_length_mm, fill = species)) +
  geom_histogram(binwidth = 2, position = "identity", alpha = 0.7)
```

We made two changes. We made it so each species has a separate
histogram starting from a count of 0. And we made the bars partially transparent
with the `alpha` argument. (0 is totally transparent, 1 is totally solid
colors.) It's a little wonky, but we can pretty much read each histogram now.

Instead, let's switch to box-and-whisker plots. These use a different geometry,
`geom_boxplot`, and they will have a continuous variable for one axis, and
usually also a discrete variable (e.g., species) for the other axis. Let's
stick with bill length and species and make three vertical boxplots, one for
each species.

```{r}
ggplot(data = penguins,
  mapping = aes(x = species, y = bill_length_mm)) +
  geom_boxplot()
```

This is easier to look at. We can see quite clearly that Adelie Penguins have
the lowest bill length, while the Chinstrap and Gentoo Penguin samples have
subtantial overlap in bill length.

## Part 3: Exploring (15 minutes, self-led)

Use the code chunks below to try out some plotting with a new variable.

1.  Create a histogram like the fancy, partially transparent one we made above,
    but for the variable `bill_depth_mm` instead of bill length, still using the
    `fill` aesthetic with the `species` column. Hint: copy and paste that 
    code into the chunk below, then switch the variable name(s) as needed.

```{r}

# write your code in this chunk

```


2.  Now create a boxplot with `species` as the x-axis and `bill_depth_mm` as the
    y-axis.

```{r}

# write your code in this chunk

```

3.  Compare with your results for bill length. Bill depth refers to the
    thickness (top to bottom) of a bill, while bill length is the distance from
    the base of the bill to the tip. Which species seems to have an overall
    short, thick bill? Which species seems to have an overall long, skinny bill?
    Double-check by googling the species to see some photos.

*Remove this and add your text notes here.*

4.  Try to fix these snippets of broken code. You will note that we have added
    an option to these code chunks that says "eval = FALSE". That is how we say
    that RStudio should not try to actually run (evaluate) that code when
    knitting the Rmd file into HTML. Because the code is broken, it you tried to
    knit when "eval = TRUE" (i.e. when RStudio will try to run that code), then
    it will return and error and your code won't knit. Feel free to remove that
    option or switch it to "eval = TRUE" after you have fixed the code for each
    chunk. ***Note: if you are ever trying to knit a HW and your code is
    returning errors, you can always set those chunks to "eval = FALSE" if you
    want to still be able to submit your knit file.***

Chunk 1 -- this plot won't run.

```{r}
# uncomment the code below and try to fix it

#ggplot(data = penguins,
#  x = species,
#  y = body_mass_g) +
#  geom_boxplot()
```

Chunk 2 -- a blank plot won't do.

```{r}
ggplot(data = penguins,
  mapping = aes(x = species, y = bill_depth_mm))
  geom_violin()
```

5.  **(Time permitting.)** The code below creates a scatterplot with bill length
    and bill depth, while also color coding the points. Review the code, then
    try to do the same thing for a boxplot of bill length, color-coding each box
    for the species it represents.

```{r}
ggplot(data = penguins,
  mapping = aes(x = bill_length_mm, 
                y = bill_depth_mm,
                color = species)) +
  geom_point()

```

## Wrapping up (5 minutes)

Knit your file to HTML, and save the original Rmd, then add them to your WFC 98
folder on Google Drive.

--------------------------------------------------------------------------------

--------------------------------------------------------------------------------

## Extra material

-   Start on HW 2.
-   Look over the intro chapter on data visualization in the R for Data Science
    textbook <https://r4ds.hadley.nz/data-visualize>. Here are a few things to
    try out.
    -   Add a `geom_smooth()` layer on top of `geom_point()` for one of the
        scatterplots we made. What does it do?
    -   Check out `geom_density()` instead of `geom_histogram()` in one of our
        histogram-making code chunks above. What does it do? Try adding the
        argument `adjust = 1/2` or `adjust = 2` and see how it changes the
        shape. (You will need to remove the `bin` or `binwidth` options, because
        those are only relevant for `geom_histogram()`).
    -   Try out the exercises in section 2.4.3.
-   Try to make the same scatterplot we made in our very first plot, but using
    `penguins_raw` instead of penguins. Can R handle column names that have
    spaces in them? (Hint: using the left quote symbol, \`, on either side of
    the name will allow R to understand that you are trying to refer to a column
    name.)
-   Check out this code and plot below. It is a prettier version of our boxplot for
    culmen length. Google some of the additional layers I added to see how to 
    create and modify them yourself.
    You may want to explore themes, explained more on [this website](https://ggplot2.tidyverse.org/reference/ggtheme.html). Rob often finds
    himself using `theme_bw()` and `theme_classic()`.

```{r}
ggplot(data = penguins,
  mapping = aes(x = species, y = bill_length_mm)) +
  geom_boxplot() +
  geom_jitter(width = .1) +
  theme_classic() +
  labs(x = "", y = "culmen length (mm)")
```

<!--chapter:end:09-lab3_2024.Rmd-->


# Lab 4: Visualizing data in R (Part 2)

In this lab, we will learn several more plotting skills.

By the end of this lab, you should be able to:

-   use `geom_jitter()` to deal with overlapping points,
-   adjust attributes like `color` and `fill`, rather than only using them as aesthetics with a particular variable,
-   add themes to make your plots more attractive,
-   customize your x- and y-axis labels and add a plot title.

### Resources

We will work with a new data set today based on lizard measurements. These data
have been tidied up by data scientist Allison Horst.
Much of what we explore today has been modified by a plotting tutorial she
created, which is available online here: [https://allisonhorst.github.io/rice-data-viz/](https://allisonhorst.github.io/rice-data-viz/).


## Part 0: Figure of the week (5-10 minutes, instructor leading)

--------------------------------------------------------------------------------

--------------------------------------------------------------------------------

## Part 1: New data! (5 minutes, instructor leading)

This is mostly review from what you learned at the end of Monday's lecture. 

### Loading data

You can load data into R in several ways. We started with the easiest: loading
a R package that includes some data frames. Another pleasantly simple way
to load data is read a csv (spreadsheet) file directly from where it is
hosted online. Let's do that now, with the help of the `read.csv()` function.

```{r}
# loading a csv file from this URL. The header argument just tells R
# that the first row is not data, but is instead a header
# with column names
lizards <- read.csv("https://raw.githubusercontent.com/allisonhorst/rice-data-viz/gh-pages/data_tidy/lizards.csv",
                    header = TRUE)

# loading tidyverse for our plotting and data wrangling needs
library(tidyverse)
```

### About these data (for reference, not for discussion during lab)
The full data are available [here](https://doi.org/10.6073/pasta/4a6e258fb49c31e222ecbbcfd128967f),
and are from another long-term ecological research site, this time for lizards 
in New Mexico.

The data include time (date of trapping), species names, some 
aspects of where they were sampled, some qualitative features (age/sex), and
some quantitative variables like `sv_length` (snout-vent length).

For reference, here are some plots we made at the end of Monday's lecture.
They will not appear because this code chunk is set to `eval = FALSE`.

```{r, eval = FALSE}
# scatterplot of length vs. body weight
ggplot(data = lizards, aes(x = total_length, y = weight)) +
  geom_point() 

# reminder that line plots are rarely appropriate
ggplot(data = lizards, aes(x = total_length, y = weight)) +
  geom_line() 
# AHHHH, THOSE LINES ARE MEANINGLESS AND SCARY`

# visualizing a single continuous variable with a histogram
ggplot(data = lizards, aes(x = total_length)) +
  geom_histogram()
```


## Independent work (25 minutes)

Let's begin with a new geometry called `geom_jitter()`.  When do we need it?
When we have lots of points that have the exact same value. In that case,
you can't fully see all your data points. `geom_jitter()` is just a variant of 
`geom_point()` that will slightly randomly shift points so you can see
points that are on top of each other more clearly.

Compare these two plots.

```{r}
# many points have the exact same weight, making this look sparse
ggplot(data = lizards, aes(y = common_name, x = weight)) +
  geom_point()

# the jitter will reveal just how many measurements we have
ggplot(data = lizards, aes(y = common_name, x = weight)) +
  geom_jitter()

```

### Task 1: working with `geom_jitter()`

Make the same two plots for snout-vent length (`sv_length`) rather than 
weight. Hint: copy and paste, then change the column/variable inside of `aes()`.

```{r}

# write your code and comments in this chunk

```

### Making consistent changes to data attributes

We use `aes()` when we want to use a variable/column from our data and 
represent it with a visual attribute (e.g. x- or y-value, color, size).
But we might want to stylize our plot to consistently have blue points, 
or red shapes, or larger lines. Here is an example.

```{r}
ggplot(data = lizards, aes(y = common_name, x = sv_length)) +
  geom_boxplot(color = "blue",
              fill = "light green",
              linetype = "dotted")
```

### Task 2: changing attributes throughout a plot

Using the same aesthetics, create a violin plot. Make the interior of each violin
colored "light blue" with a "blue" border. Use the argument `width = 0.8` to 
make the violins a bit skinnier (80% of their usual thickness).

```{r}

# write your code in this chunk

```


### Adding a theme

In lecture we have briefly noted that adding a theme layer provides a quick
way to make the plot more visually pleasing.  Here we can demonstrate a
not-super-attractive theme, and then you can explore.

```{r}
# creating a violin plot with a dark theme
ggplot(data = lizards, aes(y = common_name, x = sv_length)) +
  geom_violin(fill = "light blue") +
  theme_dark()
```

Check out the other themes here: [https://ggplot2.tidyverse.org/reference/ggtheme.html](https://ggplot2.tidyverse.org/reference/ggtheme.html).

### Task 3: themes

Create a scatterplot with snout-vent length on the x-axis and weight on the
y-axis. *Add a theme layer using one of the themes from the website above.*
Try a few themes until you find one you like, and don't just use
`theme_dark()` again.

```{r}

# write your code in this chunk

```

### Customizing labels

As we have seen in lecture, adding a `labs()` layer is a simple way to make x- and y-axis
labels that are clearer to your reader. 

```{r}
# adding labels to our previous plot
ggplot(data = lizards, aes(y = common_name, x = sv_length)) +
  geom_violin(fill = "light blue") +
  theme_dark() +
  labs(x = "snout-vent length (mm)", 
       y = "",
       title = "Length distributions for New Mexico lizards")

```

The `sv_length` variable was unclear, so I make the new x-axis label state
the full name (and units, which are listed in section 2.2 of Allison Horst's tutorial).
I also elected make the y-axis label blank, because common name is self-explanatory.
To do so, I just make the y-axis label be a set of empty quotes "". 
Finally, I added a title. 



### Interlude: finding data for the Data Story assignment

One particularly useful source for ecological data is data dryad.
<https://datadryad.org/>

Take a moment now to search for a topic you are interested in, for example
"desert tortoise conservation" or "american bison".  You might find a
number of data sets related to your interests.  For now, just try to make
sense of the page for a data set, e.g. <https://datadryad.org/stash/dataset/doi:10.5061/dryad.k3j9kd56m>

There will always be a link to download the data (sometimes multiple files). 
On the right side, there is sometimes a link to a published paper about the
data.  For the tortoise data, it is <https://academic.oup.com/beheco/article/28/4/1075/3808891>.

And there is often a readme.txt file with details about exact what the data
in each column mean. In this case there isn't, but perhaps the published
paper can help you make sense of the data.

Spend five minutes searching around for potential data sets.  
**Don't get too excited yet! Find the right, usable data set that you really
understand is way more valuable than finding a confusing data set on a
cool topic.** So just explore for now.


### Task 4: Nice labels (time permitting)
To prep for this next task, I will preview a data-tidying skill we will learn next week.

```{r}
# creating a data frame with only side-blotched lizards
# make sure the tidyverse is loaded before using filter() in this way

lizard_side_blotched <- filter(lizards, common_name == "side-blotched lizard")

```

Create a histogram of `total_length` for our new data frame, `lizard_side_blotched`.
change the `fill` and/or `color` attributes to make it nice-looking, add a theme, 
and add better labels. The y-axis label should be "frequency". You can decide 
on the x-axis label and title, but make sure they are descriptive.

```{r}

# write your code in this chunk

```

## Wrapping up (5 minutes)

Knit your file to HTML, and save the original Rmd, then add them to your WFC 98
folder on Google Drive.

--------------------------------------------------------------------------------

--------------------------------------------------------------------------------

## Extra material for interest (will not be assessed on any homework)

Work on HW 3.

Look over the next section of the tutorial, which covers some additional skills for plot customization: [https://allisonhorst.github.io/rice-data-viz/#5_Advanced_ggplot2_customization](https://allisonhorst.github.io/rice-data-viz/#5_Advanced_ggplot2_customization)

You will discover a lot of ways to customize the finer-scale details of your 
plots. Play around to create a beautiful and effective plot of some variables 
of your choosing. Consider layers like scales, for example plotting using a 
logarithmic scale rather than linear, or adjusting the spacing of breaks/tick 
marks on a plot.

```{r}

# write your code in this chunk

```

<!--chapter:end:10-lab4_2024.Rmd-->

# Lab 5: Data Story Work, Wrangling Warm-up

In this lab, we will do a tiny big of wrangling, but mostly focus on getting 
things started for the Data Story. More wrangling to come in the next two weeks.

By the end of this lab, you should be able to:

-   use `filter()` to select of subset of a data frame,
-   add faceting to plots,
-   describe the potential wrangling process for a data set for your Data Story.

### Resources

We will work with a new data set today based on small mammal trapping to
assess biodiversity in different types of plots. These data are explored
in detail in the Data Carpentry course "Data Analysis and Visualisation in R for Ecologists", [https://datacarpentry.org/R-ecology-lesson/index.html](https://datacarpentry.org/R-ecology-lesson/index.html). 



## Part 0: Figure of the week (5 minutes, instructor leading)

--------------------------------------------------------------------------------

--------------------------------------------------------------------------------

## Part 1: New data! (5 minutes, instructor leading)

This is mostly review about the data introduced at the end of Monday's lecture.

### Loading data

```{r}
# loading a csv file from this URL. The header argument just tells R
# that the first row is not data, but is instead a header
# with column names
mammals <- read.csv("https://raw.githubusercontent.com/refurrow/WFC70/main/portal_data_joined.csv",
                    header = TRUE)

# loading tidyverse for our plotting and data wrangling needs
library(tidyverse)
```

### About these data
The data are part of the Portal Project Teaching Database [https://figshare.com/articles/dataset/Portal_Project_Teaching_Database/1314459/10](https://figshare.com/articles/dataset/Portal_Project_Teaching_Database/1314459/10).
They come from a long-term mammal and plant monitoring study in the Chihuahuan 
Desert near Portal, Arizona.

```{r}
# getting a sense of our variables
glimpse(mammals)
```

You'll notice that we have a lot of data. The columns tell us the day, month,
and year that each observation was made, as well as the plot id, the genus and
species of each observation, a `species_id` that is a shorthand version of 
the species name, the sex, weight, and hindfoot length, and whether the 
species is a rodent, bird, rabbit, or reptile. 

Finally, `plot_type` tells us whether it was a control plot (no manipulation),
a plot where they excluded kangaroo rats for an extended period (long-term), a
plot with short-term exclusion of kangaroo rats, a plot where all rodents
were excluded, or a plot where only one species was excluded
(*Dipodomys spectabilis*).

## Part 1: visualizing size relationships

Your first activity is to explore size relationships on a filtered subset
of these data, looking at just a few species. We will get you started with
some code to filter the data.

```{r}
# selecting only genus Dipodomys, and only for the control plots
# then removing any individuals who were not identified to species (the "sp.")
dipodomys <- filter(mammals, genus == "Dipodomys" & plot_type == "Control") |>
  filter(species != "sp.")
```

We will learn more about the pipe, `|>`, next week. It is basically saying 
"Then do this", and passing your data frame on to the next line. It allows you 
to not have to re-enter the name of the data frame at every step of tidying
data. Here, after we filtered to only genus *Dipodomys* and only control plots,
we then did a second filter to remove any individuals who were just labeled
as *Dipodomys sp.* rather than the name of a specific species. (When you see
*sp.* for a species name that means that the individual was left unidentified.)

We now have a simplified data frame for only the three kangaroo rat species. 
Here are two examples of visualizing the hindfoot and weight relationships for 
each species.

```{r}
# scatterplot with color
ggplot(data = dipodomys,
       mapping = aes(x = hindfoot_length, y = weight, color = species_id)) +
  geom_point()

# faceting by species
ggplot(data = dipodomys,
       mapping = aes(x = hindfoot_length, y = weight)) +
  geom_point() +
  facet_wrap(~species)

```

### Your task (10 minutes)

Starting from the `mammals` data frame, use `filter()` to make a new data
frame called `sigmodon` that includes only species in the genus Sigmodon. With
these new data, create a violin plot of hindfoot length, colored by sex, and
faceted by species. You should find the code above to be very helpful.

```{r}

# write your code and comments in this chunk

```


## Part 2: a wrangling plan

You proposed some potential data sets for your Data Story in your HW 3
submission. Use the rest of today's class to explore at least one of these
data sets more deeply.

In particular, focus today on what kind of data wrangling may need to be done
in order to get your data ready for making your Data Story plots. Here are
a few guiding questions.

* What are the columns of interest in my data? What type of data is each column
(e.g., numeric, categorical, text)?

* Is the data structured in a "long" format for use with ggplot(), where
each row is an observation?

* Do the data need cleaning? Are there rows that need to be filtered out?
Are there columns that have a mix of numeric and text data (which will make
R force the whole column to be character/text data)?

* Do the data need any enriching/transformation? Do I want to make a new 
column based on data in other columns? Do I need to combine two or more data
frames (e.g., combining weather data with mammal trapping data for each night)?

* Do I need to summarize the data in any way, e.g., by calculating means and
standard errors for certain ages or by sex?

* How can I validate the data to catch any errors with my coding, or errors
with the raw data?  (Make a plan of certain plots that you can use to 
double-check that the data generally make sense and show the expected patterns.)



***

Write your notes/answers here for future reference. You may end up using some 
of this text when writing your Data Story. 

***


## Wrapping up (5 minutes)

Knit your file to HTML, and save the original Rmd, then add them to your WFC 98
folder on Google Drive.


***

## Extra material

1. Work on HW 4.

2. Try out the exploratory data analysis activity below.


### Transforming the data (scary code behind the scenes)

Run the code below to create a new data frame that summarizes the diversity 
at each plot for each year.

```{r}
# creating a function to calculate Shannon's diversity index
shannon <- function(x)
{
  proportions <- table(x)/length(x)
  D <- -sum(proportions*log(proportions))
  return(D)
}

# calculating the diversity of rodents in two ways, after filtering data
mammals_diversity <- mammals |>
  filter(taxa == "Rodent" & genus != "Dipodomys") |>
  filter(genus != "Rodent" & species != "sp.") |>
  group_by(plot_id, year) |>
  summarize(richness = length(unique(species_id)),
            shannon_d = shannon(species_id)) |>
  mutate(plot_type = case_match(plot_id,
                                c(2,4,8,11,12,14,17,22) ~ "control",
                                c(3,15,19,21) ~ "krat long-term exclosure",
                                c(5,7,10,16,23,24) ~ "all rodent exclosure",
                                c(6,13,18,20) ~ "krat short-term exclosure",
                                c(1,9) ~ "spectab exclosure"))
```

We have two different measurements of diversity. The `richness` column
is just a count of exactly how many different rodent species were found 
in that plot in that year.  The `shannon_d` column is a measure of 
Shannon's diversity index. That value quantifies diversity in a way that
includes species richness but also species evenness (whether there were
many common species, or just a few common species and many rare species).  
Ecologists generally consider a community to be more diverse if there are 
many common species, rather than just a few common species and lots of rare 
species.

### Your task

Using the mammals diversity data, try to identify if there are differences 
in diversity based on plot type, if there have been changes in diversity 
through time, or both. Try plotting the data in many ways, with different
plot types and different combinations of which variables are shown using
x-values, y-values, colors, facets, etc. Remember that we have two different
measures of diversity. This kind of quick plotting in many ways is a key part 
of exploratory data analysis.

***Create an effective figure to illustrate a pattern that you have found.***

```{r}

# enter your code and comments here

```





<!--chapter:end:11-lab5_2024.Rmd-->

# Lab 6: Mark-recapture

Note: Had to remove code chunks so the coding looks slightly messy

In this lab, we will use our wrangling skills to clean up a data frame
in order to estimate population sizes using mark-recapture. 

By the end of this lab, you should be able to:

-   calculate a population estimate from mark-recapture data,
-   use one of the `_join()` functions to combine different data frames that
have a shared "key" column, 
-   use `bind_rows()` to combine multiple data frames with 
identical columns.

### Resources

We will use the data discussed during the mark-recapture lectures. These are
data from a LTER (Long-term Ecological Research) site called the San Joaquin
Experimental Range.  
[https://data.neonscience.org/data-products/DP1.10072.001](https://data.neonscience.org/data-products/DP1.10072.001)


--------------------------------------------------------------------------------

## Part 1: Reminder of lecture data (10 minutes, instructor leading)

This code should align with what we covered during lecture. Note, however,
that you don't even have to do the Schnabel calculation by hand. With the
right vectors for M, T, and R, that final line does the multiplying, adding,
and dividing, and should yield exactly what we found during lecture.

```{r}
# loading tidyverse for our plotting and data wrangling needs

library(tidyverse)
```

```{r, eval=FALSE}
#loading data

sjer_jan17 <- read.csv("https://raw.githubusercontent.com/refurrow/WFC70/main/mam_pertrapnight_2017_01_basic.csv")

```

```{r, eval=FALSE}
 #wrangling for a simpler data set with just one species
 
pebo_jan17 <- sjer_jan17 |>  #start with the full data, THEN
  filter(scientificName == "Peromyscus boylii") |> #filter for P. boylii, THEN
  select(collectDate, tagID, recapture, fate, plotID, nlcdClass) # selecting only these columns

# creating a table from the date column and the recapture column
 
pebo_table <- table(pebo_jan17$collectDate,pebo_jan17$recapture)
pebo_table

 #entering our mark-recapture data
 
pebo_M <- c(4, 14)
pebo_T <- c(12, 6)
pebo_R <- c(2, 4)

 #adding up sum of M*T values, then dividing by sum of R values
 
sum(pebo_M*pebo_T)/sum(pebo_R)
```

You estimate 22 individuals in this population, using the Schnabel estimator.
Okay, in a moment we will set you loose to try things on your own, but
first let's do a quick `_join()`.

## Adding weather data (joining data frames)

Small mammal activity at night may depend on nighttime temperature or
precipitation, so it would be interesting to see whether our sample size
varies depending on the weather conditions.  (For example, if our mice
are inactive in very cold weather, we will expect to catch fewer mice in 
our traps on cold nights.)


```{r, eval=FALSE}

# weather for the site
# the csv was having formatting issues, so we switched here to loading
# a txt file using read.delim()
sjer_weather <- read.delim("https://raw.githubusercontent.com/refurrow/WFC70/main/sjer_weather.txt")
```

We have many fewer rows, because for each night we just have a single
suite of measurements (rather than separate rows for each individual
caught in our original data). `lowTemp` is the lowest temperature that night
in degrees Fahrenheit, and `precip` is the overall rainfall in the previous
24 hours, in inches.

To think about overall activity, let's not simply focus on *P. boylii*. Let's 
instead use all of our data. We'll want to remove all the rows with
empty traps and only include rows with captures. There are many ways
we could filter here. I noticed that the recapture column is always the empty
string, "", when the trap was empty and always has a value when an individual
was caught, so we can filter by removing all the empty rows. The exclamation 
point, !, means NOT, so we will filter the rows that are NOT equal to "".

getting all catches (not just P. boylii)
 
catches_jan17 <- sjer_jan17 |>
  filter(recapture != "")  only rows that are NOT equal to the empty string, "".

```

Now, let's join. We don't care about the February or October weather, so let's 
prioritize the rows in our catch data. 

***Pause and think. What is our shared key? What kind of join should we use?***


joining catch data and weather data

catches_jan17_full <- left_join(catches_jan17,sjer_weather, by = "collectDate")


***Pause and check. Do the data look like what we expected? Because the catch data***
***has multiple rows for each night, what is in the weather data for the***
***separate rows on the same night?***

Finally, we'll want to convert our data to a simple count per night using 
`group_by()` and `summarize()`.


weather_catch_jan17 <- catches_jan17_full |>
  group_by(collectDate) |>
  summarize(sample_size = n(), # counts number of rows (for each date)
            low_temp = first(lowTemp), # picks the first temp value 
            precip = first(precip)) # picks first precip value
            
Take a moment to view this much smaller data frame. We now have everything
we need to look at sample size versus temperature (or versus precipitation).



ggplot(weather_catch_jan17,
       mapping = aes(x = low_temp, y = sample_size)) +
  geom_point() +
  theme_classic()


Okay, we've managed some mark-recapture, joining, summarizing and plotting.
Now you can try out a second estimate on your own.

## Western harvest mouse population size (on your own, 15 minutes)

### Your data

This code will help you load the February trapping data, and filter to
just include the western harvest mouse, *Reithrodontomys megalotis*.


sjer_feb17 <- read.csv("https://raw.githubusercontent.com/refurrow/WFC70/refs/heads/main/mam_pertrapnight_2017_02_basic.csv")

rema_feb17 <- filter(sjer_feb17, scientificName== "Reithrodontomys megalotis") |>
  select(collectDate, tagID, recapture, fate, plotID, nlcdClass)


### Getting your mark-recapture table

Follow the steps from our *P. boylii* estimate to create a table with
recapture / new capture counts for each night (collectDate). (Hint: `table()` 
function.)

```{r}

# enter your code and comments here

```


Enter your data below, and uncomment and run the lines afterwards. You have
four nights (three resamples), so you'll have three values each for
M, T, and R.

```{r}
#uncomment the lines below and fill in the right values for the
#M, T, and R vectors

#rema_M <- c()
#rema_T <- c()
#rema_R <- c()

#sum(rema_M*rema_T)/sum(rema_R)


```


* ***What is your final estimate for the Feb 2017 population size?***


### More joining (time permitting)

* Create a new data frame that includes all catches for Feb 2017,
* Join it with the weather data, `sjer_weather`,
* Create an identical summary of the data for February (the only 
difference in code will be the name of the initial data frame
you are using),
* use `bind_rows()` to combine the summary from Jan and Feb,
* create a plot of temperature versus sample size for both month's data.

```{r}

# enter your code and comments here

```



## Wrapping up (5 minutes)

Knit your file to HTML, and save the original Rmd, then add them to your WFC 98
folder on Google Drive.


## Extra material

Work on HW 5.

Continue working on the Data Story.


<!--chapter:end:12-lab6_2024.Rmd-->

# Lab 7: File Management, Troubleshooting, Data Story

In this lab, we will learn the very basics of file management and 
how to load data into Rmd files when it is stored locally.

By the end of this lab, you should be able to:

-   use "Import Dataset" to load a locally stored file and then copy
the R code into an Rmd code chunk,
-   force a column to be character or numeric data to deal with issues with
how data are loaded,
-   continue exploring your data for the Data Story.

### Resources

Please download from Canvas the file "Lab7_data.zip", and save it to a folder 
on the computer. 


--------------------------------------------------------------------------------

## Part 1: Navigating file structure (10 minutes, on your own)

### Unzipping "Lab7_data.zip"

A .zip file is a compressed file that can hold many individual files. It
can be a useful way to share a set of folders with many organized files. 

To decompress it and turn it back into the original folders, you need to
"unzip" it. On a mac, just double-clicking on the folder should automatically 
unzip it to create a folder in the same directory where the .zip file is 
located. On a pc, right click and select "Extract All", then click the
"Extract" button.

At this point, you should now have a folder open with some very poorly named
subfolders (a, b, c, and d). Inside each of these are more folders with
names 1, 2, 3, and 4. And some of those folders have even more folders inside
(i, ii, iii, iv). 

The data are hidden as a csv file within folder d, then subfolder 3, then
subfolder i. Inside of that folder you should find "dispersal_fake.csv". 

### Loading the data

In the upper left of RStudio, click on the File tab, then on "Import Dataset", 
and then "From Text (base)...". This will open a window in which you need
to navigate to the file you want to load. You will need to navigate to 
where you saved the Lab8_data folder, to folder d, then folder 3, then
folder i.  

After you've selected the file, click "Import". It will create
a new data frame in your Environment. ***But more importantly, if you look***
***in the Console in the lower left, you will see the exact R code used to***
***load the data.***

There you will see that you actually just ran a `read.csv()` command, with
a very long string (the "path") with directions to the file you wanted to open.
The backslash at the end of each word or phrase indicates a folder. The start 
of the path will be different for each computer, but the end of the path should
look like "/Lab7_data/d/3/i/dispersal_fake.csv". Those are the directions to
navigate through the Lab8_data folder to get to the actual csv file.

Copy the full code from your Console into this code chunk. You need the data
to be loaded with commands inside of the Rmd if you want to be able to
use that data for more R code later in an Rmd document.

```{r}

library(tidyverse)

# copy and paste the read.csv command that makes your data frame here



# if you are struggling to make that code work, below is code
# to load the data frame from online, so that you can follow
# along with the next section. Uncomment and run it if needed.

#dispersal_fake <- read.csv("https://raw.githubusercontent.com/refurrow/WFC70/main/dispersal_fake.csv")
```

When you are working with new data for the Data Story, you should create
a folder on your computer where you save the data, and you will need to make
sure you have code within your Rmd that loads the data. Otherwise you will
encounter errors when you try to knit, because the data will not be loaded. 


## Part 2: Dealing with wonky data (10 minutes, on your own)

Let's glimpse our data.

```{r}
# uncomment the line below and run it
# glimpse(dispersal_fake)
```

When you load data into R, there are a few common issues that can arise
with how R tries to automatically identify what kind of data are in each row.

#### Issue 1: text in a numerical column. 

***Always double check that your columns are the data type that you expect.***
Reminder, "num" is numeric, "int" is integer (whole numbers), and "chr" is
character/text (string) data. Sometimes you will have a column that
is mostly numbers, but there are a few entries with text. In our case, the 
spreadsheet used the term "n/a" for missing data rather than "NA". By default,
R assumes that is text. But we can't have a column with multiple data types,
so it will default to the most flexible type. Text/character data is the 
most flexible because it can still store numbers as strings. But you won't 
be able to manipulate them.  You can fix it by forcing a column to be
numeric using `as.numeric()`.

```{r}
# using mutate to fix our distance column
# uncomment and run the lines below

#dispersal_fake <- mutate(dispersal_fake, 
#                         distance = as.numeric(distance))

```

When we used `as.numeric()`, it turned all the strings with numbers
back into numbers, and any other text became NA, which is ideal for our purpose.
So the ominous "Warning" above is just explaining that it did what we wanted --
it introduced NAs where there were non-numbers in the column.

#### Issue 2: missing data.

Sometimes a column in the spreadsheet may have some blank values. By default
for numeric data, these become NAs. You'll notice an example in the 
`age` column, where missing data is now NA. But the blank entry in `brood` is 
just the empty string, "".  So something to watch out for in R is that missing 
data becomes NAs when the column is numeric, but not in columns that are 
character/text data. See Issue 4 for a coding way to deal with that.


#### Issue 3: numbers in a character column.

You should be suspicious of a number in a column that is mostly 
character data -- it might reflect user error. I often
use `table()` on my character variables to double-check what all my 
possible entries are.

```{r}
# uncommon the code below to make the table 

#table(dispersal_fake$brood)
```
Okay, so 4.6 seems like a transcription error or something. Let's look
at the raw data by clicking on its name in the Environment. Hmm, 4.6 is
also the value for the `distance` column for that observation.  Perhaps
this should just be NA, unless we can find the correct `brood` value by 
reviewing our raw data. For making small edits to small spreadsheets, I often 
make a copy of the raw data (called "dispersal_processed.csv", for example), 
and then directly edit that file. If I do that, I add a text file in the same
folder that lists all the editing steps I performed by hand, so I can remember
exactly what I did. Often I will just replace all missing data with NA
by hand as well.

If you do edit your data, make sure you are loading the
newer, processed csv file when you write your code for the data story. Other 
wonky things can happen if R thinks certain columns are in Date format -- it 
can help to force dates to be character data using `as.character()` in some
instances.



#### Issue 4: factors are easier to plot than character data

Categorical data in R will usually be loaded as character data, even when
there are only a few possible levels/values (e.g. "small", "medium" and
"large" for our `brood` column). But there is another data type in R called
factors that is designed to handle categorical data. Converting the relevant
columns to factors can make some aspects of plotting simpler. We won't 
go in depth now, but there is a nice tutorial [linked here: https://r4ds.hadley.nz/factors](https://r4ds.hadley.nz/factors).

```{r}
# example code to remake the brood column with the levels
# small, medium, and large, in that order

# uncomment the code below to try it out

#dispersal_tidy <- dispersal_fake %>% 
#  mutate(brood = factor(brood, levels = c("small", "medium","large")))

```

Basically, factors let you more easily specify which values are listed first,
for controlling things like x-axis order or legend order, and make it easier
to convert missing data to NAs. In the example above, now any values that
were not "small", "medium", or "large" will become NA, and if you made a 
plot with brood as the x-axis aesthetic, it would order the x-axis in the
order your specified (here small, then medium, then large), rather
than alphabetically.


## Data story work (any remaining time)

For the rest of lab, continue your investigation of your data.

1. Make sure you really understand the columns and exactly what they are 
telling you.
2. Get to know the data. Try making a histogram for a column of interest to 
get a sense of the variability. If it's just categorical, use `table()` to
make a table with counts of each value.  Make scatterplots to explore the 
relationship between two numerical variables, and use violin plots to see
how the distribution of a numerical column changes based on the values in
a different categorical column. 
3. Let your curiosity guide you. How can the data tell you interesting things?
Would some background reading help you come up with new questions or 
hypotheses? Now is the time to brainstorm lots of interesting questions
that are answerable with the data.


As you load the data and explore, you may want to code directly in the Data Story 
template Rmd. That way you have your work already in the appropriate place.



## Wrapping up (5 minutes)

Knit any files to HTML, and save the original Rmd (and your Data story template
Rmd, if you have started working in it). Then add these files to your WFC 98
folder on Google Drive.


<!--chapter:end:13-lab7_2024.Rmd-->

